from typing import Tuple, List, Optional, Any, Dict, Union, Sequence

# Constants
SHAPE_BOX: int = 0
SHAPE_SPHERE: int = 1
SHAPE_CAPSULE: int = 2
SHAPE_CYLINDER: int = 3
SHAPE_PLANE: int = 4
SHAPE_MESH: int = 5

MOTION_STATIC: int = 0
MOTION_KINEMATIC: int = 1
MOTION_DYNAMIC: int = 2

CONSTRAINT_FIXED: int = 0
CONSTRAINT_POINT: int = 1
CONSTRAINT_HINGE: int = 2
CONSTRAINT_SLIDER: int = 3
CONSTRAINT_DISTANCE: int = 4
CONSTRAINT_CONE: int = 5

class Character:
    def move(self, velocity: Tuple[float, float, float], dt: float) -> None: ...
    def get_position(self) -> Tuple[float, float, float]: ...
    def set_position(self, pos: Tuple[float, float, float]) -> None: ...
    def set_rotation(self, rot: Tuple[float, float, float, float]) -> None: ...
    def is_grounded(self) -> bool: ...
    def set_strength(self, strength: float) -> None: ...
    def get_render_transform(self, alpha: float) -> Tuple[Tuple[float, float, float], Tuple[float, float, float, float]]: ...
    
    @property
    def handle(self) -> int: ...

class Vehicle:
    def set_input(
        self, 
        forward: float = 0.0, 
        right: float = 0.0, 
        brake: float = 0.0, 
        handbrake: float = 0.0
    ) -> None: ...
    def get_wheel_transform(self, index: int) -> Tuple[Tuple[float, float, float], Tuple[float, float, float, float]]: ...
    def destroy(self) -> None: ...

class PhysicsWorld:
    def __init__(
        self, 
        settings: Optional[dict] = None, 
        bodies: Optional[list[dict]] = None
    ) -> None: ...

    def step(self, dt: float = 1.0/60.0) -> None: ...

    def create_body(
        self, 
        pos: Tuple[float, float, float] = (0, 0, 0),
        rot: Tuple[float, float, float, float] = (0, 0, 0, 1),
        size: Any = (1, 1, 1),
        shape: int = 0,
        motion: int = 2,
        user_data: int = 0,
        is_sensor: bool = False
    ) -> int: ...

    def create_mesh_body(
        self,
        pos: Tuple[float, float, float],
        rot: Tuple[float, float, float, float],
        vertices: bytes,
        indices: bytes,
        user_data: int = 0
    ) -> int: ...

    def create_character(
        self,
        pos: Tuple[float, float, float],
        height: float = 1.8,
        radius: float = 0.4,
        step_height: float = 0.4,
        max_slope: float = 45.0
    ) -> Character: ...
    
    def create_vehicle(
        self,
        chassis: int,
        wheels: Sequence[Any]
    ) -> Vehicle: ...

    def destroy_body(self, handle: int) -> None: ...

    def create_constraint(self, type: int, body1: int, body2: int, params: Optional[Any] = None) -> int: ...
    def destroy_constraint(self, handle: int) -> None: ...
    
    # Interaction
    def apply_impulse(self, handle: int, x: float, y: float, z: float) -> None: ...
    def set_position(self, handle: int, x: float, y: float, z: float) -> None: ...
    def set_rotation(self, handle: int, x: float, y: float, z: float, w: float) -> None: ...
    def set_transform(self, handle: int, pos: Tuple[float, float, float], rot: Tuple[float, float, float, float]) -> None: ...
    def set_linear_velocity(self, handle: int, x: float, y: float, z: float) -> None: ...
    def set_angular_velocity(self, handle: int, x: float, y: float, z: float) -> None: ...
    def activate(self, handle: int) -> None: ...
    def deactivate(self, handle: int) -> None: ...
    
    # Properties & State
    def get_motion_type(self, handle: int) -> int: ...
    def set_motion_type(self, handle: int, motion: int) -> None: ...
    def set_user_data(self, handle: int, data: int) -> None: ...
    def get_user_data(self, handle: int) -> int: ...
    def get_index(self, handle: int) -> Optional[int]: ...
    def get_active_indices(self) -> bytes: ...
    def is_alive(self, handle: int) -> bool: ...
    
    # Queries
    def raycast(
        self, 
        start: Tuple[float, float, float], 
        direction: Tuple[float, float, float], 
        max_dist: float = 1000.0,
        ignore: Any = 0
    ) -> Optional[Tuple[int, float, Tuple[float, float, float]]]: ...
    def shapecast(
        self,
        shape: int,
        pos: Tuple[float, float, float],
        rot: Tuple[float, float, float, float],
        dir: Tuple[float, float, float],
        size: Any,
        ignore: Any = 0
    ) -> Optional[Tuple[int, float, Tuple[float, float, float], Tuple[float, float, float]]]: ...
    def overlap_sphere(self, center: Tuple[float, float, float], radius: float) -> List[int]: ...
    def overlap_aabb(self, min: Tuple[float, float, float], max: Tuple[float, float, float]) -> List[int]: ...
    
    # Event System
    def get_contact_events(self) -> List[Tuple[int, int]]: ...
    def get_contact_events_ex(self) -> List[Dict[str, Any]]: ...
    def get_contact_events_raw(self) -> memoryview: ...

    # Snapshots
    def save_state(self) -> bytes: ...
    def load_state(self, state: bytes) -> None: ...

    # Interpolation
    def get_render_state(self, alpha: float) -> bytes: ...

    # Shadow Buffers
    @property
    def positions(self) -> memoryview: ...
    @property
    def rotations(self) -> memoryview: ...
    @property
    def velocities(self) -> memoryview: ...
    @property
    def angular_velocities(self) -> memoryview: ...
    @property
    def user_data(self) -> memoryview: ... 
    @property
    def count(self) -> int: ...
    @property
    def time(self) -> float: ...