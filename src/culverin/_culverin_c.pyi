from typing import Tuple, List, Optional, Any, Dict, Union, Sequence
from . import _culverin_c

# Constants
SHAPE_BOX: int = 0
SHAPE_SPHERE: int = 1
SHAPE_CAPSULE: int = 2
SHAPE_CYLINDER: int = 3
SHAPE_PLANE: int = 4
SHAPE_MESH: int = 5
SHAPE_HEIGHTFIELD: int = 6
SHAPE_CONVEX_HULL: int = 7

MOTION_STATIC: int = 0
MOTION_KINEMATIC: int = 1
MOTION_DYNAMIC: int = 2

CONSTRAINT_FIXED: int = 0
CONSTRAINT_POINT: int = 1
CONSTRAINT_HINGE: int = 2
CONSTRAINT_SLIDER: int = 3
CONSTRAINT_DISTANCE: int = 4
CONSTRAINT_CONE: int = 5

EVENT_ADDED: int = 0
EVENT_PERSISTED: int = 1
EVENT_REMOVED: int = 2

class Character:
    def move(self, velocity: Tuple[float, float, float], dt: float) -> None: ...
    def get_position(self) -> Tuple[float, float, float]: ...
    def set_position(self, pos: Tuple[float, float, float]) -> None: ...
    def set_rotation(self, rot: Tuple[float, float, float, float]) -> None: ...
    def is_grounded(self) -> bool: ...
    def set_strength(self, strength: float) -> None: ...
    def get_render_transform(self, alpha: float) -> Tuple[Tuple[float, float, float], Tuple[float, float, float, float]]: ...
    @property
    def handle(self) -> int: ...

class Vehicle:
    def set_input(self, forward: float = 0.0, right: float = 0.0, brake: float = 0.0, handbrake: float = 0.0) -> None: ...
    def set_tank_input(self, left: float, right: float, brake: float = 0.0) -> None: ...
    def get_wheel_transform(self, index: int) -> Tuple[Tuple[float, float, float], Tuple[float, float, float, float]]: ...
    def get_wheel_local_transform(self, index: int) -> Tuple[Tuple[float, float, float], Tuple[float, float, float, float]]: ...
    def get_debug_state(self) -> None: ...
    def destroy(self) -> None: ...
    @property
    def wheel_count(self) -> int: ...

class Skeleton:
    def add_joint(self, name: str, parent_index: int = -1) -> int: ...
    def finalize(self) -> None: ...

class RagdollSettings:
    def add_part(self, joint_index: int, shape_type: int, size: Any, mass: float, parent_index: int, 
                 twist_min: float = -0.1, twist_max: float = 0.1, cone_angle: float = 0.0, 
                 axis: Tuple[float,float,float]=(1,0,0), normal: Tuple[float,float,float]=(0,1,0),
                 pos: Tuple[float,float,float]=(0,0,0)) -> None: ...
    def stabilize(self) -> bool: ...

class Ragdoll:
    def drive_to_pose(self, root_pos: Tuple[float,float,float], root_rot: Tuple[float,float,float,float], matrices: bytes) -> None: ...
    def get_body_handles(self) -> List[int]: ...
    def get_debug_info(self) -> List[Dict[str, Any]]: ...

class PhysicsWorld:
    def __init__(self, settings: Optional[dict] = None, bodies: Optional[List[dict]] = None) -> None: ...
    def step(self, dt: float = 1.0/60.0) -> None: ...
    
    def create_body(self, **kwargs) -> int: ...
    def create_mesh_body(self, pos: Tuple[float, float, float], rot: Tuple[float, float, float, float], 
                         vertices: bytes, indices: bytes, **kwargs) -> int: ...
    def create_character(self, pos: Tuple[float, float, float], **kwargs) -> Character: ...
    
    def create_vehicle(self, chassis: int, wheels: Sequence[Any], drive: str = "RWD", 
                       engine: Optional[Any] = None, transmission: Optional[Any] = None) -> Vehicle: ...
    
    def create_tracked_vehicle(self, chassis: int, wheels: Sequence[Any], tracks: Sequence[Any], 
                               max_torque: float = 5000.0, max_rpm: float = 6000.0) -> Vehicle: ...

    def create_ragdoll_settings(self, skeleton: Skeleton) -> RagdollSettings: ...
    def create_ragdoll(self, settings: RagdollSettings, pos: Tuple[float, float, float], **kwargs) -> Ragdoll: ...
    def create_heightfield(self, pos: Tuple[float, float, float], rot: Tuple[float, float, float, float], 
                           scale: Tuple[float, float, float], heights: bytes, grid_size: int, **kwargs) -> int: ...
    def create_convex_hull(self, pos: Tuple[float, float, float], rot: Tuple[float, float, float, float], 
                           points: bytes, **kwargs) -> int: ...
    def create_compound_body(self, pos: Tuple[float, float, float], rot: Tuple[float, float, float, float], 
                             parts: List[Tuple[Any, Any, int, Any]], **kwargs) -> int: ...

    def destroy_body(self, handle: int) -> None: ...
    def create_constraint(self, type: int, body1: int, body2: int, params: Optional[Any] = None) -> int: ...
    def destroy_constraint(self, handle: int) -> None: ...
    def apply_impulse(self, handle: int, x: float, y: float, z: float) -> None: ...
    def apply_impulse_at(self, handle: int, ix: float, iy: float, iz: float, px: float, py: float, pz: float) -> None: ...
    def apply_force(self, handle: int, x: float, y: float, z: float) -> None: ...
    def apply_torque(self, handle: int, x: float, y: float, z: float) -> None: ...
    def apply_angular_impulse(self, handle: int, x: float, y: float, z: float): ...
    def set_gravity(self, gravity: Tuple[float, float, float]) -> None: ...
    def get_body_stats(self, handle: int) -> Optional[Tuple[Tuple[float, float, float], Tuple[float, float, float, float], Tuple[float, float, float]]]: ...
    def apply_buoyancy(self, handle: int, surface_y: float, **kwargs) -> bool: ...
    def apply_buoyancy_batch(self, handles: Union[bytes, memoryview, Sequence[int]], surface_y: float = 0.0, **kwargs) -> None: ...
    def register_material(self, id: int, friction: float = 0.5, restitution: float = 0.0) -> None: ...
    def set_position(self, handle: int, x: float, y: float, z: float) -> None: ...
    def set_rotation(self, handle: int, x: float, y: float, z: float, w: float) -> None: ...
    def set_transform(self, handle: int, pos: Tuple[float, float, float], rot: Tuple[float, float, float, float]) -> None: ...
    def set_linear_velocity(self, handle: int, x: float, y: float, z: float) -> None: ...
    def set_angular_velocity(self, handle: int, x: float, y: float, z: float) -> None: ...
    def set_ccd(self, handle: int, enabled: bool) -> None: ...
    def activate(self, handle: int) -> None: ...
    def deactivate(self, handle: int) -> None: ...
    def get_motion_type(self, handle: int) -> int: ...
    def set_motion_type(self, handle: int, motion: int) -> None: ...
    def set_user_data(self, handle: int, data: int) -> None: ...
    def get_user_data(self, handle: int) -> int: ...
    def set_collision_filter(self, handle: int, category: int, mask: int) -> None: ...
    def raycast(self, start: Tuple[float, float, float], direction: Tuple[float, float, float], 
                max_dist: float = 1000.0, ignore: int = 0) -> Optional[Tuple[int, float, Tuple[float, float, float]]]: ...
    def raycast_batch(self, starts: bytes, directions: bytes, max_dist: float = 1000.0) -> bytes: ...
    def shapecast(self, shape: int, pos: Tuple[float, float, float], rot: Tuple[float, float, float, float],
                  dir: Tuple[float, float, float], size: Any, ignore: int = 0) -> Optional[Tuple[int, float, Tuple[float, float, float], Tuple[float, float, float]]]: ...
    def overlap_sphere(self, center: Tuple[float, float, float], radius: float) -> List[int]: ...
    def overlap_aabb(self, min: Tuple[float, float, float], max: Tuple[float, float, float]) -> List[int]: ...
    def get_contact_events(self) -> List[Tuple[int, int]]: ...
    def get_contact_events_ex(self) -> List[Dict[str, Any]]: ...
    def get_contact_events_raw(self) -> memoryview: ...
    def get_debug_data(self, **kwargs) -> Tuple[bytes, bytes]: ...
    def get_index(self, handle: int) -> Optional[int]: ...
    def get_active_indices(self) -> bytes: ...
    def is_alive(self, handle: int) -> bool: ...
    def save_state(self) -> bytes: ...
    def load_state(self, state: bytes) -> None: ...
    def get_render_state(self, alpha: float) -> bytes: ...

    @property
    def positions(self) -> memoryview: ...
    @property
    def rotations(self) -> memoryview: ...
    @property
    def velocities(self) -> memoryview: ...
    @property
    def angular_velocities(self) -> memoryview: ...
    @property
    def user_data(self) -> memoryview: ... 
    @property
    def count(self) -> int: ...
    @property
    def time(self) -> float: ...
    @property
    def shape_count(self) -> int: ...